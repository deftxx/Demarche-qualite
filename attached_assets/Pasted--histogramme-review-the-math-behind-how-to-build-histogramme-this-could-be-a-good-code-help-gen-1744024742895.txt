*histogramme review the math behind how to build histogramme :

this could be a good code help generated by me, adapt it to the project  :

import numpy as np
import matplotlib.pyplot as plt

def generate_histogram_with_stats(data, bins=10, title="Histogram with Statistics", color='skyblue', edgecolor='black'):
    """
    Generate a histogram and calculate key statistics (count, mean, median, min, max).
    
    Parameters:
    -----------
    data : array-like
        Input data for the histogram
    bins : int or sequence, optional
        Number of bins or bin edges
    title : str, optional
        Title for the histogram
    color : str, optional
        Color for the histogram bars
    edgecolor : str, optional
        Color for the histogram bar edges
        
    Returns:
    --------
    stats : dict
        Dictionary containing the calculated statistics
    """
    # Calculate statistics
    stats = {
        "Count": len(data),
        "Mean": np.mean(data),
        "Median": np.median(data),
        "Min": np.min(data),
        "Max": np.max(data)
    }
    
    # Create figure and axis
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Plot histogram
    ax.hist(data, bins=bins, color=color, edgecolor=edgecolor, alpha=0.7)
    
    # Add statistics text box
    stats_text = "\n".join([f"{key}: {value:.2f}" if isinstance(value, float) else f"{key}: {value}" 
                           for key, value in stats.items()])
    
    props = dict(boxstyle='round', facecolor='white', alpha=0.7)
    ax.text(0.05, 0.95, stats_text, transform=ax.transAxes, fontsize=12,
            verticalalignment='top', bbox=props)
    
    # Add labels and title
    ax.set_xlabel('Value')
    ax.set_ylabel('Frequency')
    ax.set_title(title)
    
    # Add grid
    ax.grid(True, alpha=0.3)
    
    # Show plot
    plt.tight_layout()
    plt.show()
    
    return stats

# Example usage
if __name__ == "__main__":
    # Generate sample data
    np.random.seed(42)
    sample_data = np.random.normal(loc=50, scale=15, size=1000)
    
    # Generate histogram and get statistics
    stats = generate_histogram_with_stats(sample_data, bins=20, 
                                          title="Sample Normal Distribution")
    
    print("Statistics:")
    for key, value in stats.items():
        print(f"{key}: {value:.2f}" if isinstance(value, float) else f"{key}: {value}")

* correlation review the math behind correlation statistics 

this could be a good code help generated by me, adapt it to the project  :

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats

def analyze_correlation(x, y, method='pearson', title="Correlation Analysis", 
                        xlabel="X Variable", ylabel="Y Variable", figsize=(12, 8)):
    """
    Analyze correlation between two variables with visualizations and statistics.
    
    Parameters:
    -----------
    x : array-like
        First variable data
    y : array-like
        Second variable data
    method : str, optional
        Correlation method: 'pearson', 'spearman', or 'kendall'
    title : str, optional
        Title for the plots
    xlabel : str, optional
        Label for x-axis
    ylabel : str, optional
        Label for y-axis
    figsize : tuple, optional
        Figure size
        
    Returns:
    --------
    results : dict
        Dictionary containing correlation statistics
    """
    # Convert inputs to numpy arrays
    x = np.array(x)
    y = np.array(y)
    
    # Check if inputs have the same length
    if len(x) != len(y):
        raise ValueError("Input arrays must have the same length")
        
    # Create DataFrame for easier analysis
    df = pd.DataFrame({xlabel: x, ylabel: y})
    
    # Calculate correlations
    if method == 'pearson':
        corr_coef, p_value = stats.pearsonr(x, y)
        corr_type = 'Pearson'
    elif method == 'spearman':
        corr_coef, p_value = stats.spearmanr(x, y)
        corr_type = 'Spearman'
    elif method == 'kendall':
        corr_coef, p_value = stats.kendalltau(x, y)
        corr_type = 'Kendall'
    else:
        raise ValueError("Method must be 'pearson', 'spearman', or 'kendall'")
    
    # Calculate coefficient of determination (R-squared)
    if method == 'pearson':
        r_squared = corr_coef**2
    else:
        # For non-parametric methods, we calculate a pseudo R-squared
        r_squared = corr_coef**2
        
    # Calculate covariance
    covariance = np.cov(x, y)[0, 1]
    
    # Prepare results dictionary
    results = {
        f"{corr_type} Correlation": corr_coef,
        "P-value": p_value,
        "R-squared": r_squared,
        "Covariance": covariance,
        "Sample Size": len(x)
    }
    
    # Determine correlation strength description
    abs_corr = abs(corr_coef)
    if abs_corr < 0.3:
        strength = "Weak"
    elif abs_corr < 0.7:
        strength = "Moderate"
    else:
        strength = "Strong"
        
    direction = "Positive" if corr_coef > 0 else "Negative"
    significance = "Significant" if p_value < 0.05 else "Not significant"
    
    # Create figure with subplots
    fig, axs = plt.subplots(2, 2, figsize=figsize)
    fig.suptitle(f"{title}\n{direction} {strength} Correlation ({significance})", fontsize=16)
    
    # Scatter plot with regression line
    sns.regplot(x=xlabel, y=ylabel, data=df, ax=axs[0, 0], scatter_kws={'alpha': 0.5})
    axs[0, 0].set_title('Scatter Plot with Regression Line')
    
    # Hexbin plot for density
    hb = axs[0, 1].hexbin(x, y, gridsize=20, cmap='Blues')
    axs[0, 1].set_title('Hexbin Density Plot')
    axs[0, 1].set_xlabel(xlabel)
    axs[0, 1].set_ylabel(ylabel)
    fig.colorbar(hb, ax=axs[0, 1], label='Count')
    
    # Joint distributions
    sns.kdeplot(x=x, ax=axs[1, 0], color='blue')
    axs[1, 0].set_title(f'{xlabel} Distribution')
    axs[1, 0].set_xlabel(xlabel)
    
    sns.kdeplot(x=y, ax=axs[1, 1], color='green')
    axs[1, 1].set_title(f'{ylabel} Distribution')
    axs[1, 1].set_xlabel(ylabel)
    
    # Add correlation statistics text box
    stats_text = "\n".join([f"{key}: {value:.4f}" if isinstance(value, float) else f"{key}: {value}" 
                           for key, value in results.items()])
    
    props = dict(boxstyle='round', facecolor='white', alpha=0.7)
    axs[0, 0].text(0.05, 0.95, stats_text, transform=axs[0, 0].transAxes, fontsize=10,
                verticalalignment='top', bbox=props)
    
    plt.tight_layout()
    plt.subplots_adjust(top=0.85)
    plt.show()
    
    return results

# Example usage
if __name__ == "__main__":
    # Generate sample data with positive correlation
    np.random.seed(42)
    x = np.random.normal(0, 1, 100)
    y = x * 0.8 + np.random.normal(0, 0.5, 100)  # Strong positive correlation
    
    # Analyze correlation
    results = analyze_correlation(x, y, method='pearson', 
                              title="Example Correlation Analysis",
                              xlabel="Variable X", ylabel="Variable Y")
    
    print("Correlation Statistics:")
    for key, value in results.items():
        print(f"{key}: {value:.4f}" if isinstance(value, float) else f"{key}: {value}")
        
    # Example with negative correlation
    y_neg = -x * 0.6 + np.random.normal(0, 0.7, 100)  # Moderate negative correlation
    
    results_neg = analyze_correlation(x, y_neg, method='spearman', 
                                  title="Negative Correlation Example",
                                  xlabel="Variable X", ylabel="Variable Y")